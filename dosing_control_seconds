#include <math.h>  // fabs()

// Recalibrated: Automated Dosing Control Logic
// Arduino GIGA R1
// ======================================================
// New Logic: Implements a CRITICAL EC Check (Salt Toxicity Guardrail)
// to prevent dosing that would worsen a lethal salt crisis.

// ------------ Pump Pins (Active HIGH) ------------
const int PUMP_SODIUM_BICARB   = 2; // For raising pH (Increases EC)
const int PUMP_CITRIC_ACID     = 3; // For lowering pH
const int PUMP_DEIONIZED_WATER = 4; // For lowering EC / raising ORP (Dilution)
const int PUMP_MOLASSES        = 5; // For lowering ORP / raising EC (Food)
const int PUMP_URINE           = 6; // For raising EC / pH (Nutrient)
const int PUMP_SPIRULINA       = 7; // For raising EC / pH (Nutrient)

const unsigned long DOSING_INTERVAL_MS = 300000; // Dosing frequency: 5 minutes (300,000 ms)

// ------------ Sensor Pins ------------
const int PH_PIN   = A0;
const int ORP_PIN  = A1;
const int EC_PIN   = A2;
const int MFC_PIN  = A3; // MFC is read but ignored for control logic

// ------------ System Target Ranges ------------
// **CRITICAL: ADJUST THESE VALUES BASED ON YOUR BIOLOGICAL OPTIMA**
const float TARGET_PH_L = 6.8;
const float TARGET_PH_H = 7.2;
const float TARGET_EC_L = 4.0; // mS/cm
const float TARGET_EC_H = 5.0; // mS/cm

// NEW CRITICAL SAFETY LIMIT
const float CRITICAL_EC_H = 10.0; // mS/cm: Above this level, halt all dosing to prevent salt poisoning.

// SWAPPED L and H to reflect that -250mV is 'lower' than -150mV
const float TARGET_ORP_L = -250.0; // mV  <-- MOST negative limit (healthy)
const float TARGET_ORP_H = -150.0; // mV  <-- LEAST negative limit (stressed)

// ------------ Calibration Constants ------------
const float VREF = 3.3;
const int   ADC_MAX = 4095;

const float PH_SLOPE     = -5.59047;
const float PH_INTERCEPT = 15.835;

const float EC_SLOPE_MSPERMV = 0.00864;
const float EC_OFFSET_MS     = 0.033;

const float ORP_OFFSET = -1524.0;
const int ORP_OVERSAMPLES = 50;

// ------------ Timing Variables ------------
unsigned long lastDosingTime = 0;
unsigned long lastSensorRead = 0;
const unsigned long SENSOR_INTERVAL = 5000; // Read sensors every 5 seconds

// ======================================================
// Data type must be defined BEFORE any function prototypes that use it
// ======================================================
struct SensorData {
  float pH;
  float EC_mS;
  float ORP_mV;
  float MFC_mV;
};

// ======================================================
// Adaptive dosing configuration (per pump)
// ======================================================
const int PUMP_COUNT = 6;

const int pumpPins[PUMP_COUNT] = {
  PUMP_SODIUM_BICARB,
  PUMP_CITRIC_ACID,
  PUMP_DEIONIZED_WATER,
  PUMP_MOLASSES,
  PUMP_URINE,
  PUMP_SPIRULINA
};

// Start each pump at 1 second (tunes automatically)
unsigned long pumpPulseMs[PUMP_COUNT] = {1000, 1000, 1000, 1000, 1000, 1000};

// Limits + step size
const unsigned long PULSE_STEP_MS = 1000;
const unsigned long PULSE_MIN_MS  = 500;
const unsigned long PULSE_MAX_MS  = 8000;

// After dosing, wait a bit for mixing before judging effect
const unsigned long POST_DOSE_MIX_MS = 20000; // 20 seconds (tune this)

// "Not enough change" thresholds (tune to your sensor noise)
const float MIN_PH_DELTA  = 0.02;  // pH units
const float MIN_EC_DELTA  = 0.02;  // mS/cm
const float MIN_ORP_DELTA = 5.0;   // mV

// "Too big change" thresholds (tune to prevent overshoot)
const float MAX_PH_DELTA  = 0.15;  // pH units
const float MAX_EC_DELTA  = 0.30;  // mS/cm
const float MAX_ORP_DELTA = 40.0;  // mV

// ------------ Forward Declarations ------------
SensorData readSensors();
void readAndPrintSensors();
void executeControlLogic();

int  pumpIndexFromPin(int pumpPin);
void Actuate_Pump_Adaptive(int pumpPin, const char* message, const SensorData& before);

// ======================================================
void setup() {
  Serial.begin(115200);
  while (!Serial);

  Serial.println("Starting Automated Dosing Control...");
  Serial.println("EC CRITICAL LIMIT SET: 10.0 mS/cm (Dosing will halt above this!)");

  analogReadResolution(12);

  // Initialize all pump pins
  pinMode(PUMP_SODIUM_BICARB, OUTPUT);
  pinMode(PUMP_CITRIC_ACID, OUTPUT);
  pinMode(PUMP_DEIONIZED_WATER, OUTPUT);
  pinMode(PUMP_MOLASSES, OUTPUT);
  pinMode(PUMP_URINE, OUTPUT);
  pinMode(PUMP_SPIRULINA, OUTPUT);

  // Ensure all pumps are OFF
  digitalWrite(PUMP_SODIUM_BICARB, LOW);
  digitalWrite(PUMP_CITRIC_ACID, LOW);
  digitalWrite(PUMP_DEIONIZED_WATER, LOW);
  digitalWrite(PUMP_MOLASSES, LOW);
  digitalWrite(PUMP_URINE, LOW);
  digitalWrite(PUMP_SPIRULINA, LOW);

  lastDosingTime = millis() - DOSING_INTERVAL_MS; // Force first dosing attempt immediately
}

// ======================================================
void loop() {
  unsigned long currentTime = millis();

  // 1. Sensor Reading Loop (High Frequency)
  if (currentTime - lastSensorRead >= SENSOR_INTERVAL) {
    readAndPrintSensors();
    lastSensorRead = currentTime;
  }

  // 2. Dosing Control Loop (Low Frequency)
  if (currentTime - lastDosingTime >= DOSING_INTERVAL_MS) {
    executeControlLogic();
    lastDosingTime = currentTime;
  }
}

// ======================================================
// Sensor Reading Function (Used by both loops)
// ======================================================
SensorData readSensors() {
  SensorData data;

  // ---------- pH ----------
  int ph_raw = analogRead(PH_PIN);
  float ph_voltage = ph_raw * (VREF / ADC_MAX);
  data.pH = PH_SLOPE * ph_voltage + PH_INTERCEPT;

  // ---------- ORP (simple offset only) ----------
  long sum = 0;
  for (int i = 0; i < ORP_OVERSAMPLES; i++) {
    sum += analogRead(ORP_PIN);
    delayMicroseconds(100);
  }
  float orp_raw = sum / (float)ORP_OVERSAMPLES;
  float orp_mV = (orp_raw * VREF / ADC_MAX) * 1000.0;
  data.ORP_mV = orp_mV + ORP_OFFSET;

  // ---------- EC ----------
  int ec_raw = analogRead(EC_PIN);
  float ec_mV = (float)ec_raw * 3300.0 / 4095.0;
  data.EC_mS = EC_SLOPE_MSPERMV * ec_mV + EC_OFFSET_MS;

  // ---------- MFC Voltage ----------
  int mfc_raw = analogRead(MFC_PIN);
  data.MFC_mV = (float)mfc_raw * 3300.0 / 4095.0;

  return data;
}

void readAndPrintSensors() {
  SensorData data = readSensors();
  Serial.print("pH: ");
  Serial.print(data.pH, 2);
  Serial.print("   |   ORP_mV: ");
  Serial.print(data.ORP_mV, 1);
  Serial.print("   |   EC_mS: ");
  Serial.print(data.EC_mS, 3);
  Serial.print("   |   MFC_mV: ");
  Serial.println(data.MFC_mV, 1);
}

// ======================================================
// Dosing Logic Function
// ======================================================
void executeControlLogic() {
  SensorData data = readSensors(); // Read fresh data for decision

  Serial.println("--- Starting Dosing Check ---");

  // CRITICAL SAFETY CHECK (Priority 0: Halt all dosing if EC is lethally high)
  if (data.EC_mS > CRITICAL_EC_H) {
    Serial.println("!!! CRITICAL EC WARNING !!!");
    Serial.print("EC (");
    Serial.print(data.EC_mS, 2);
    Serial.print(" mS/cm) is ABOVE LETHAL LIMIT (");
    Serial.print(CRITICAL_EC_H, 1);
    Serial.println(" mS/cm). HALTING ALL DOSING.");
    Serial.println("Manual intervention is REQUIRED to dilute contents.");
    return; // HALT AND DO NOT DOSE ANYTHING
  }

  // PH CONTROL (Priority 1)
  if (data.pH < TARGET_PH_L) {
    Actuate_Pump_Adaptive(PUMP_SODIUM_BICARB, "pH LOW: Adding Sodium Bicarbonate", data);
    return;
  } else if (data.pH > TARGET_PH_H) {
    Actuate_Pump_Adaptive(PUMP_CITRIC_ACID, "pH HIGH: Adding Citric Acid", data);
    return;
  }

  // EC CONTROL (Priority 2)
  if (data.EC_mS < TARGET_EC_L) {
    if (data.pH < TARGET_PH_H - 0.1) {
      Actuate_Pump_Adaptive(PUMP_SPIRULINA, "EC LOW: Adding Powdered Spirulina (to also raise pH)", data);
    } else {
      Actuate_Pump_Adaptive(PUMP_URINE, "EC LOW: Adding Urine", data);
    }
    return;
  } else if (data.EC_mS > TARGET_EC_H) {
    Actuate_Pump_Adaptive(PUMP_DEIONIZED_WATER, "EC HIGH: Adding Deionized Water (to lower EC)", data);
    return;
  }

  // ORP CONTROL (Priority 3)
  if (data.ORP_mV < TARGET_ORP_L) {
    Actuate_Pump_Adaptive(PUMP_DEIONIZED_WATER, "ORP LOW: Adding Deionized Water", data);
    return;
  } else if (data.ORP_mV > TARGET_ORP_H) {
    Actuate_Pump_Adaptive(PUMP_MOLASSES, "ORP HIGH: Adding Molasses", data);
    return;
  }

  Serial.println("System is Stable. No Dosing Required.");
}

// ======================================================
// Adaptive Pump Functions
// ======================================================
int pumpIndexFromPin(int pumpPin) {
  for (int i = 0; i < PUMP_COUNT; i++) {
    if (pumpPins[i] == pumpPin) return i;
  }
  return -1;
}

void Actuate_Pump_Adaptive(int pumpPin, const char* message, const SensorData& before) {
  int idx = pumpIndexFromPin(pumpPin);
  if (idx < 0) {
    Serial.println("ERROR: Unknown pump pin!");
    return;
  }

  Serial.print("DOSING: ");
  Serial.println(message);

  Serial.print("Pulse (ms): ");
  Serial.println(pumpPulseMs[idx]);

  // Dose
  digitalWrite(pumpPin, HIGH);
  delay(pumpPulseMs[idx]);
  digitalWrite(pumpPin, LOW);

  Serial.println("DOSING COMPLETE. Waiting for mixing...");
  delay(POST_DOSE_MIX_MS);

  // Re-read and evaluate effect
  SensorData after = readSensors();

  float dPH  = fabs(after.pH     - before.pH);
  float dEC  = fabs(after.EC_mS  - before.EC_mS);
  float dORP = fabs(after.ORP_mV - before.ORP_mV);

  Serial.print("Effect | dPH: ");  Serial.print(dPH, 3);
  Serial.print("  dEC: ");         Serial.print(dEC, 3);
  Serial.print("  dORP: ");        Serial.println(dORP, 1);

  bool tooSmall = (dPH < MIN_PH_DELTA) && (dEC < MIN_EC_DELTA) && (dORP < MIN_ORP_DELTA);
  bool tooBig   = (dPH > MAX_PH_DELTA) || (dEC > MAX_EC_DELTA) || (dORP > MAX_ORP_DELTA);

  if (tooSmall) {
    unsigned long old = pumpPulseMs[idx];
    unsigned long next = pumpPulseMs[idx] + PULSE_STEP_MS;
    pumpPulseMs[idx] = constrain(next, PULSE_MIN_MS, PULSE_MAX_MS);

    Serial.print("ADAPT: Too small/no response -> increasing pulse from ");
    Serial.print(old);
    Serial.print(" to ");
    Serial.println(pumpPulseMs[idx]);
  } else if (tooBig) {
    unsigned long old = pumpPulseMs[idx];
    long next = (long)pumpPulseMs[idx] - (long)PULSE_STEP_MS;
    if (next < (long)PULSE_MIN_MS) next = (long)PULSE_MIN_MS;
    if (next > (long)PULSE_MAX_MS) next = (long)PULSE_MAX_MS;
    pumpPulseMs[idx] = (unsigned long)next;

    Serial.print("ADAPT: Overshoot/too large -> decreasing pulse from ");
    Serial.print(old);
    Serial.print(" to ");
    Serial.println(pumpPulseMs[idx]);
  } else {
    Serial.println("ADAPT: Change looks OK -> keeping pulse the same.");
  }

  // Print post-dose readings
  Serial.print("POST | pH: ");     Serial.print(after.pH, 2);
  Serial.print(" ORP: ");          Serial.print(after.ORP_mV, 1);
  Serial.print(" EC: ");           Serial.print(after.EC_mS, 3);
  Serial.print(" MFC: ");          Serial.println(after.MFC_mV, 1);
}
